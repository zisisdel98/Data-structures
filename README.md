Στο ερώτημα Α έκανα τη δικιά μου δομή για την ουρά προτεραιότητας με
generics γιατί ήθελα να προσθέσω λειτουργίες στην ουρά μου, που δεν τις
είχε η έτοιμη του φροντιστηρίου όπως την get_the_size που επιστρέφει το
μέγεθος της ουράς και την modify που ήταν απαραίτητη για να τροποποιώ το
περιεχόμενο ενός στοιχείο που έχω προσθέσει ήδη στην ουρά. Επιπλέον,
έφτιαξα μια κλάση Disk που θα αποθηκεύει μέσα του μία λίστα με Folders
που έχει αποθηκευμένους και μια κλάση Folder που κρατάει τα στοιχεία του
κάθε Folder (MaxPQ, Disk, Folder).
Στο ερώτημα Β έκανα την κλάση Greedy η οποία αρχικά υπολογίζει τον
αριθμό των αρχείων που περιέχει το txt αρχείο που του έδωσα σαν όρισμα,
έπειτα δημιουργεί μια ουρά που αποθηκεύεις αντικείμενα τύπου Disk.
Επιπλέον, έφτιαξα ένα πίνακα με αντικείμενα τύπου Folder και έναν με
αντικείμενα τύπου Disk. Η γενικότερη φιλοσοφία για την κατανομή των
αρχείων ήταν ότι βρίσκουμε τον δίσκο με τον περισσότερο ελεύθερο χώρο αν
χωράει το αρχείο μας το προσθέτουμε στο ήδη υπάρχον αντικείμενο στην
ουρά προτεραιότητας, τροποποιούμε το περιεχόμενό του και τοποθετείται ο
Δίσκος στη σωστή θέση της ουράς προτεραιότητας με βάση πια το νέο
ελεύθερο χώρο του. Αν ο φάκελος δεν χωράει σε κανέναν υπάρχων δίσκο
τότε δημιουργείται νέος δίσκος. Τέλος, αν ο αριθμός των φακέλων εντός του
txt αρχείου που δώσαμε σαν όρισμα είναι μικρότερος από 100 τότε
εμφανίζονται οι δίσκοι ταξινομημένοι κατά φθίνουσα σειρά με βάση τον
ελευθέρο χώρο που τους έχει απομείνει καθώς και τα Folders που έχει
αποθηκευμένα ο κάθε Disk.
Στο ερώτημα Γ έκανα αρχικά την κλάση Sort, μία τυπική υλοποίηση του
αλγορίθμου MergeSort. Έπειτα, έφτιαξα την κλάση Greedy2 που είναι η
δεύτερη πιο ορθή υλοποίηση του αλγορίθμου του ερωτήματος Β. Η διαφορά
είναι ότι εδώ πρώτα ταξινομώ κατά φθίνουσα σειρά τα Folders με βάση το
μέγεθος τους και έπειτα κάνω ακριβώς την ίδια διαδικασία με τον αλγόριθμο
Greedy του ερωτήματος Β.
Στο ερώτημα Δ
Αρχικά έκανα την κλάση Experiment που δημιουργεί τα 30 txt αρχεία και τα
γεμίζει με αριθμούς από το 0 έως το 1.000.000 (Ν1,Ν2,Ν3 πλήθος μεγεθών
ανα δεκάδα παραγόμενων txt files αντίστοιχα) που απεικονίζουν τα μεγέθη
των αρχείων. Η random χρησιμοποιήθηκε στην ουσία για να παραχθούν 3
τυχαίοι αριθμοι N1,N2,N3 που ήταν ο αριθμός των μεγεθών που περιέχει το
κάθε txt αρχείο και επίσης για να γραφτούν N1,N2,N3 τυχαίοι αριθμόι που
εκφράζουν το μέγεθος από 0 έως 1000000 σε κάθε txt αρχείο που
δημιουργήθηκε. Για να προχωρήσω στο επόμενο βήμα εκτελώ το εκτελέσιμο
αρχείο Experiment.class που παράγεται μετά τη μεταγλώττιση.
Έπειτα, έκανα την κλάση GvsG2 προκειμένου να συγκρίνουμε τα
αποτελέσματα των αλγορίθμων Greedy και Greedy2 για όλα τα αρχεία που
δημιούργησα με την Experiment. Το πρώτο πράγμα που πρέπει να γίνει είναι
να δώσει ο χρήστης στην οποία ο χρήστης το path των αρχείων που είναι
αποθηκευμένα τα αρχεία που δημιουργήθηκαν από την Experiment στη
μορφή C:\Users\zisis\Desktop\project\src, δηλαδή μέχρι και τον φάκελο που
είναι αποθηκευμένα τα αρχεία και η κλάση GvsG2 προσθέτει αυτόματα το
υπόλοιπο πχ \test_n11.txt, \test_n28.txt, \test_n34.txt. Για να μπορέσω να
χρησιμοποιήσω τα δεδομένα για τον αριθμό των δίσκων που χρησιμοποιεί ο
κάθε αλγόριθμος δημιουργώ δύο αντικείμενα σε κάθε επανάληψη το ένα
τύπου Greedy και το άλλο τύπου Greedy2. Έπειτα, αθροίζω για κάθε μπλοκ
επαναλήψεων τον αριθμό των δίσκων που χρησιμοποιήθηκαν από τον
αλγόριθμο Greedy και τον αλγόριθμο Greedy2 και μετά υπολογίζω τους
μέσους όρους. Από τον υπολογισμό των μέσων όρων γίνεται κατανοητό ότι ο
αλγόριθμος Greedy2 χρησιμοποιεί σαφώς λιγότερους δίσκους από τον
Greedy.
